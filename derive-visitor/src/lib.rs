#![warn(clippy::all)]
#![warn(clippy::pedantic)]

//! This crate derives [visitor pattern](https://rust-unofficial.github.io/patterns/patterns/behavioural/visitor.html)
//! for arbitrary data structures. This pattern is particularly useful when dealing with complex nested data structures,
//! abstract trees and hierarchies of all kinds.
//!
//! The main building blocks of this crate are two derivable traits:
//! - [Visitor] implementations walk through data structures and accumulates some information;
//! - [Drive] implementations are data structures that know how to drive a visitor through themselves.
//!
//! Please refer to these traits' documentation for more details.
//!
//! ## Example
//!
//! ```
//! use derive_visitor::{Visitor, Drive};
//!
//! #[derive(Drive)]
//! struct Directory {
//!     #[drive(skip)]
//!     name: String,
//!     items: Vec<DirectoryItem>,
//! }
//!
//! #[derive(Drive)]
//! enum DirectoryItem {
//!     File(File),
//!     Directory(Directory),
//! }
//!
//! #[derive(Drive)]
//! struct File {
//!     #[drive(skip)]
//!     name: String,
//! }
//!
//! #[derive(Visitor, Default)]
//! #[visitor(File(enter), Directory(enter))]
//! struct Counter {
//!     files: u32,
//!     directories: u32
//! }
//!
//! impl Counter {
//!     fn enter_file(&mut self, _file: &File) {
//!         self.files += 1;
//!     }
//!     fn enter_directory(&mut self, _directory: &Directory) {
//!         self.directories += 1;
//!     }
//! }
//!
//! let mut counter = Counter::default();
//!
//! let example_directory = Directory {
//!     name: "root".into(),
//!     items: vec![
//!         DirectoryItem::Directory(
//!             Directory {
//!                 name: "home".into(),
//!                 items: vec![
//!                     DirectoryItem::File(File { name: "README.md".into() }),
//!                     DirectoryItem::File(File { name: "Star Wars.mov".into() })
//!                 ]
//!             }
//!         ),
//!         DirectoryItem::Directory(
//!             Directory { name: "downloads".into(), items: vec![] }
//!         )
//!     ],
//! };
//!
//! example_directory.drive(&mut counter);
//!
//! assert_eq!(counter.files, 2);
//! assert_eq!(counter.directories, 3);
//! ```
//!
//! ## Features
//! - `std-types-drive` - implement [Drive](Drive) for primitive types and String type from std.
//! It is [recommended](https://github.com/nikis05/derive-visitor/issues/3#issuecomment-1186690655) to
//! either skip these types in your `Drive` implementation, or to wrap them with newtypes, so this feature
//! is disabled by default. However it might be useful when driving through autogenerated structs.

/// See [Drive].
pub use derive_visitor_macros::Drive;

/// See [Visitor].
pub use derive_visitor_macros::Visitor;

use std::{any::Any, cell::Cell, marker::PhantomData};

#[cfg(feature = "std-types-drive")]
use std::ops::{Range, RangeBounds, RangeFrom, RangeInclusive, RangeTo, RangeToInclusive};

/// An interface for visiting arbitrary data structures.
///
/// A visitor receives items that implement [Any], and can use dynamic dispatch
/// to downcast them to particular types that it is interested in. In the classical
/// visitor pattern, a Visitor has a set of separate methods to deal with each particular
/// item type. This behavior can be implemented automatically using derive.
///
/// ## Derivable
///
/// This trait can be derived for any struct or enum. By default, the derived implementation
/// does nothing. You need to explicitly specify what item types and / or events your visitor
/// is interested in, using top-level attribute:
///
/// ```ignore
/// #[derive(Visitor)]
/// #[visitor(Directory, File)]
/// struct NameValidator {
///     errors: Vec<InvalidNameError>,
/// }
///
/// impl NameValidator {
///     fn enter_directory(&mut self, item: &Directory) {
///         // ...your logic here
///     }
///     fn exit_directory(&mut self, item: &Directory) {
///         // ...your logic here
///     }
///     fn enter_file(&mut self, item: &File) {
///         // ...your logic here
///     }
///     fn exit_file(&mut self, item: &File) {
///         // ...your logic here
///     }
/// }
/// ```
///
/// ## Visitor functions / closures
/// If your visitor is only interested in some particular type, you don't have to declare a struct,
/// you can just create a visitor from a closure or a function, e.g.:
///
/// ```ignore
/// let file_visitor = visitor_fn(|file: &File, event| {
///     // ...your logic here
/// });
/// ```
///
/// See [visitor_fn](visitor_fn) and [visitor_enter_fn](visitor_enter_fn) for more info.
///
/// ## Macro attributes
///
/// If your visitor is only interested in [Event::Enter](Event::Enter) or [Event::Exit](Event::Exit),
/// you can configure the derived implementation to only call enter / exit, respectively,
/// on a per-type basis:
///
/// ```ignore
/// #[derive(Visitor)]
/// #[visitor(Directory(enter), File(exit))]
/// struct NameValidator {
///     errors: Vec<InvalidNameError>,
/// }
///
/// impl NameValidator {
///     fn enter_directory(&mut self, item: &Directory) {
///         // ...your logic here
///     }
///     fn exit_file(&mut self, item: &File) {
///         // ...your logic here
///     }
/// }
/// ```
///
/// You can also provide custom method names for each type / event:
///
/// ```ignore
/// #[derive(Visitor)]
/// #[visitor(Directory(enter="custom_enter_directory", exit="custom_exit_directory"), File)]
/// struct NameValidator {
///     errors: Vec<InvalidNameError>,
/// }
///
/// impl NameValidator {
///     fn custom_enter_directory(&mut self, item: &Directory) {
///         // ...your logic here
///     }
///     fn custom_exit_directory(&mut self, item: &Directory) {
///         // ...your logic here
///     }
///     fn enter_file(&mut self, item: &File) {
///         // ...your logic here
///     }
///     fn exit_file(&mut self, item: &File) {
///         // ...your logic here
///     }
/// }
/// ```
pub trait Visitor {
    fn visit(&mut self, item: &dyn Any, event: Event);
}

/// Create a visitor that only visits items of some specific type from a function or a closure.
///
/// ## Example
/// ```ignore
/// let file_visitor = visitor_fn(|file: &File, event| {
///     // ...your logic here
/// });
/// ```
pub fn visitor_fn<T: Any, F: FnMut(&T, Event)>(fun: F) -> FnVisitor<T, F> {
    FnVisitor {
        _marker: PhantomData,
        fun,
    }
}

/// Similar to [visitor_fn](visitor_fn), but the closure will only be called on [Event::Enter](Event::Enter).
pub fn visitor_enter_fn<T: Any, F: FnMut(&T)>(fun: F) -> EnterFnVisitor<T, F> {
    EnterFnVisitor {
        _marker: PhantomData,
        fun,
    }
}

/// Type returned by [visitor_fn](visitor_fn).
pub struct FnVisitor<T: Any, F: FnMut(&T, Event)> {
    _marker: PhantomData<*const T>,
    fun: F,
}

impl<T: Any, F: FnMut(&T, Event)> Visitor for FnVisitor<T, F> {
    fn visit(&mut self, item: &dyn Any, event: Event) {
        if let Some(item) = <dyn Any>::downcast_ref::<T>(item) {
            let fun = &mut self.fun;
            fun(item, event);
        }
    }
}

/// Type returned by [visitor_enter_fn](visitor_enter_fn).
pub struct EnterFnVisitor<T: Any, F: FnMut(&T)> {
    _marker: PhantomData<*const T>,
    fun: F,
}

impl<T: Any, F: FnMut(&T)> Visitor for EnterFnVisitor<T, F> {
    fn visit(&mut self, item: &dyn Any, event: Event) {
        if let (Event::Enter, Some(item)) = (event, <dyn Any>::downcast_ref::<T>(item)) {
            let fun = &mut self.fun;
            fun(item);
        }
    }
}

/// Defines whether an item is being entered or exited by a visitor.
pub enum Event {
    Enter,
    Exit,
}

/// A data structure that can drive a [visitor](Visitor) through iself.
///
/// Derive or implement this trait for any type that you want to be able to
/// traverse with a visitor.
///
/// `Drive` is implemented for most wrapping and collection types from [std],
/// as long as their wrapped / item type implements `Drive`.
///
/// ## Derivable
///
/// This trait can be derived for any struct or enum.
/// By default, the derived implementation will make the visitor enter `self`,
/// then drive it through every field of `self`, and finally make it exit `self`:
///
/// ```ignore
/// #[derive(Drive)]
/// struct Directory {
///     #[drive(skip)]
///     name: String,
///     items: Vec<DirectoryItem>,
/// }
///
/// #[derive(Drive)]
/// enum DirectoryItem {
///     File(File),
///     Directory(Directory),
/// }
///
/// #[derive(Drive)]
/// struct File {
///     #[drive(skip)]
///     name: String,
/// }
/// ```
///
/// ## Implementing manually
///
/// The following code snippet is roughly equivalent to the implementations
/// that would be derived in the example above:
///
/// ```ignore
/// impl Drive for Directory {
///     fn drive<V: Visitor>(&self, visitor: &mut V) {
///         visitor.visit(self, Event::Enter);
///         self.items.drive(visitor);
///         visitor.visit(self, Event::Exit);
///     }
/// }
///
/// impl Drive for DirectoryItem {
///     fn drive<V: Visitor>(&self, visitor: &mut V) {
///         visitor.visit(self, Event::Enter);
///         match self {
///             Self::File(file) => {
///                 file.drive(visitor);
///             },
///             Self::Directory(directory) => {
///                 directory.drive(visitor);
///             }
///         }
///         visitor.visit(self, Event::Exit);
///     }
/// }
///
/// impl Drive for File {
///     fn drive<V: Visitor>(&self, visitor: &mut V) {
///         visitor.visit(self, Event::Enter);
///         visitor.visit(self, Event::Exit);
///     }
/// }
/// ```
///
/// ## Macro attributes
///
/// The derived implementation of `Drive` can be customized using attributes:
///
/// ### `#[drive(skip)]`
///
/// If applied to a field or an enum variant, the derived implementation won't
/// drive the visitor through that field / variant.
///
/// If applied to a struct or an enum itself, the derived implementation will
/// drive the visitor through the type's fields / variants, but won't make it
/// enter or exit the type itself.
///
/// ### `#[drive(with="path")]`
///
/// Drive a visitor through a field using a custom function.
/// The function must have the following signature: `fn<V: Visitor>(&T, &mut V)`.
///
/// In the example below, this attribute is used to customize driving through a [Vec]:
///
/// ```ignore
/// #[derive(Drive)]
/// struct Book {
///     title: String,
///     #[drive(with="reverse_vec_driver")]
///     chapters: Vec<Chapter>,
/// }
///
/// fn reverse_vec_driver<T, V: Visitor>(vec: &Vec<T>, visitor: &mut V) {
///     for item in vec.iter().rev() {
///         item.drive(visitor);
///     }
/// }
/// ```
pub trait Drive: Any {
    fn drive<V: Visitor>(&self, visitor: &mut V);
}

// Helper trait to the generic `IntoIterator` Drive impl
trait DerefAndDrive {
    fn deref_and_drive<V: Visitor>(self, visitor: &mut V);
}

// Most collections iterate over item references, this is the trait impl that handles that case
impl<T: Drive> DerefAndDrive for &T {
    fn deref_and_drive<V: Visitor>(self, visitor: &mut V) {
        self.drive(visitor);
    }
}

// Map-like collections iterate over item references pairs
impl<TK: Drive, TV: Drive> DerefAndDrive for (&TK, &TV) {
    fn deref_and_drive<V: Visitor>(self, visitor: &mut V) {
        self.0.drive(visitor);
        self.1.drive(visitor);
    }
}

// The following should be able to handle almost all container types:
// array, BTreeMap, BTreeSet, BinaryHeap, slice, HashMap, HashSet, LinkedList, Vec, VecDeque
//
// It even handles Option, since it has a trivial IntoIterator impl.
impl<T> Drive for T
where
    T: 'static,
    // HRTB, because this needs to be true for late-bound lifetimes,
    // as both &self and &visitor have anonymous lifetimes.
    for<'a> &'a T: IntoIterator,
    for<'a> <&'a T as IntoIterator>::Item: DerefAndDrive,
{
    fn drive<V: Visitor>(&self, visitor: &mut V) {
        for item in self {
            item.deref_and_drive(visitor);
        }
    }
}

impl<T> Drive for Box<T>
where
    T: Drive,
{
    fn drive<V: Visitor>(&self, visitor: &mut V) {
        (**self).drive(visitor);
    }
}
impl<T> Drive for Cell<T>
where
    T: Drive + Copy,
{
    fn drive<V: Visitor>(&self, visitor: &mut V) {
        self.get().drive(visitor);
    }
}

impl Drive for () {
    fn drive<V: Visitor>(&self, _visitor: &mut V) {}
}

macro_rules! tuple_impls {
    ( $( $( $type:ident ),+ => $( $field:tt ),+ )+ ) => {
        $(
            impl<$( $type ),+> Drive for ($($type,)+)
            where
                $(
                    $type: Drive
                ),+
            {
                fn drive<V: Visitor>(&self, visitor: &mut V) {
                    $(
                        self.$field.drive(visitor);
                    )+
                }
            }
        )+
    };
}

tuple_impls! {
    T0 => 0
    T0, T1 => 0, 1
    T0, T1, T2 => 0, 1, 2
    T0, T1, T2, T3 => 0, 1, 2, 3
    T0, T1, T2, T3, T4 => 0, 1, 2, 3, 4
    T0, T1, T2, T3, T4, T5 => 0, 1, 2, 3, 4, 5
    T0, T1, T2, T3, T4, T5, T6 => 0, 1, 2, 3, 4, 5, 6
    T0, T1, T2, T3, T4, T5, T6, T7 => 0, 1, 2, 3, 4, 5, 6, 7
}

#[cfg(feature = "std-types-drive")]
macro_rules! trivial_impl {
    ( $type:ident ) => {
        impl Drive for $type {
            fn drive<V: Visitor>(&self, visitor: &mut V) {
                visitor.visit(self, Event::Enter);
                visitor.visit(self, Event::Exit);
            }
        }
    };
}

#[cfg(not(feature = "std-types-drive"))]
macro_rules! trivial_impl {
    ( $type:ident ) => {};
}

trivial_impl!(u8);
trivial_impl!(u16);
trivial_impl!(u32);
trivial_impl!(u64);
trivial_impl!(u128);
trivial_impl!(usize);

trivial_impl!(i8);
trivial_impl!(i16);
trivial_impl!(i32);
trivial_impl!(i64);
trivial_impl!(i128);
trivial_impl!(isize);

trivial_impl!(f32);
trivial_impl!(f64);

trivial_impl!(char);
trivial_impl!(bool);

trivial_impl!(String);

#[cfg(feature = "std-types-drive")]
macro_rules! range_impl {
    ( $type:ident) => {
        impl<T: Drive> Drive for $type<T> {
            fn drive<V: Visitor>(&self, visitor: &mut V) {
                // This long form is needed instead of just .start and .end, because
                // Not only does RangeFrom and RangeTo not have one of the fields, but
                // for some reason both fields are private in RangeInclusive, and instead
                // start() and end() functions have to be called
                if let std::ops::Bound::Included(b) | std::ops::Bound::Excluded(b) =
                    self.start_bound()
                {
                    b.drive(visitor);
                }
                if let std::ops::Bound::Included(b) | std::ops::Bound::Excluded(b) =
                    self.end_bound()
                {
                    b.drive(visitor);
                }
            }
        }
    };
}

#[cfg(not(feature = "std-types-drive"))]
macro_rules! range_impl {
    ( $type:ident) => {};
}

range_impl!(Range);
range_impl!(RangeInclusive);
range_impl!(RangeFrom);
range_impl!(RangeTo);
range_impl!(RangeToInclusive);
